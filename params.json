{"name":"cdxr.github.io","tagline":"","body":"## Craig's Projects\r\nMany of my projects are open source and [hosted on github](https://github.com/cdxr).\r\nThis page is an overview of my work in Haskell.\r\n\r\n\r\n### hurl\r\n[hurl](https://github.com/cdxr/haskell-hurl)\r\nis a high-level interface to the Chipmunk physics library that is in\r\nearly development. It is based on the `Hipmunk` package, which is a more or\r\nless straightforward (yet high-quality) binding to the C library.\r\n\r\nThe purpose of `hurl` is to provide a more idiomatic and expressive API than\r\n`Hipmunk`. The most important goal in this regard is the use of functional\r\nreactive programming to structure collision handling rather than using\r\ncallbacks.\r\n\r\n\r\n### mutate\r\nMy [mutate](https://github.com/cdxr/haskell-mutate) package is an attempt to\r\nformalize the relationships between various types of mutable variables such\r\nas IORefs, STRefs, and TVars.\r\n\r\nThe original motivation of this library was to be able to write operators and\r\nlarger abstractions that would simply do what you expect with different kinds\r\nof mutable variables.\r\n\r\nThis has proven more complicated than I originally anticipated. Types such as\r\nIORef, STRef, TVar, and StateVar support similar operations but have subtle\r\nsemantic differences in regards to exceptions and concurrency. It is an ongoing\r\nproject.\r\n\r\n\r\n### drawing 2-D graphics\r\n\r\n[tooty](https://github.com/cdxr/haskell-tooty)\r\n(pronounced like 2-D) is a simple DSL for 2-dimensional drawing in\r\nOpenGL. OpenGL is incredibly stateful, and often painful to use in Haskell.\r\n`tooty` offers a functional-style API for drawing, but does not try to\r\nencapsulate the details of OpenGL from the user.\r\n\r\nAn earlier experiment of mine, `draw`, was a library similar in spirit to\r\n`tooty` but using SDL for graphics instead of OpenGL. In that library, drawing\r\ncomputations were expressed in terms of a monad `Context c a` where `c`\r\nconstrained the capabilities of the drawing context. It was a fun concept\r\nand I might return to it in the future, but next time using type-level\r\nrecords to manage capabilities.\r\n\r\n\r\n### experiments\r\n\r\n[tree-writer](https://github.com/cdxr/tree-writer) defines\r\nControl.Monad.TreeWriter. It is a small specialized\r\nversion of the WriterT monad transformer used to construct rose trees.\r\nIt was a neat idea but I've found myself using `pipes` in all cases\r\nwhere I might have used `tree-writer`.\r\n\r\n[weave](https://github.com/cdxr/weave) defines the `Weave` type.\r\nA `Weave c a` is isormorphic to `[Either c a]`, and can be used as a\r\ntraversable container of `a`s embedded in the monoid `c`.\r\nFor example, `Weave Text Image` represents a `Text` value with `Image`s\r\nembedded throughout it. I created `weave` because it encapsulates a general\r\npattern that I recognized in several of my projects, but I'm still determining\r\nits utility as a general abstraction.\r\n\r\n[regular-tile](https://github.com/cdxr/regular-tile-haskell)\r\nprovides the typeclass `Tile`, a subclass of `Eq` and `Monoid`. It represents\r\na regular tile in the 2-D plane (there are three types: triangles, squares, and\r\nhexagons). Expressing path-finding algorithms and other logic in terms of\r\nthe `Tile` typeclasses enable their use in libraries for boardgame-style computer\r\ngames that work in any of the three regular tilings.\r\n\r\n\r\n#### command line interfaces\r\n\r\nI am planning to develop a monadic framework for developing interactive\r\nconsole interfaces. You would use the library to define a tree\r\nof possible application states. The tree could be used to generate the\r\ncommand line arguments for your program, and could also be used to generate an\r\n\"interactive mode\" that assists a user who is unfamiliar with the program.\r\n\r\nA few of my older projects were experiments working towards this goal:\r\n\r\n[terminal](https://github.com/cdxr/terminal)\r\nprovides the mtl-style typeclass `MonadTerm`, which exposes the\r\nfunctionality of a console interface. This is currently implemented in terms of\r\nthe `haskeline` package, but it could target other backends as well.\r\n\r\n`input` was a brief experiment with the same concepts as `terminal` but\r\nexpressed using operational monads.\r\n\r\n[command](https://github.com/cdxr/command) was a simple monadic parser for\r\nstructuring application-wide state changes in response to user input on the\r\ncommand line. One goal of the project was to create a composable type\r\nrepresenting command line queries of the style (y/n). This was an old project\r\nthat I abandoned, but I might go back and rewrite it in terms of a standard\r\nparser combinator library.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}